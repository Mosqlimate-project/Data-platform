{% extends 'main/base.html' %}
{% load i18n %}
{% load plotly_dash %}
{% load static %}
{% load filters %}

{% block title %}Dashboard{% endblock %}

{% block content %}
<header>
  <link rel="stylesheet" href="{% static 'css/vis/dashboard/index.css' %}">
  <link rel="stylesheet" href="{% static 'css/external/jqrangeslider.css' %}">
  <link rel="stylesheet" href="{% static 'css/external/jquery-ui.css' %}">
</header>

<script src="{% static 'js/external/jquery.js' %}"></script>
<script
  src="https://code.jquery.com/ui/1.14.0/jquery-ui.js"
  integrity="sha256-u0L8aA6Ev3bY2HI4y0CAyr9H8FRWgX4hZ9+K7C2nzdc="
  crossorigin="anonymous"></script>
<script src="{% static 'js/external/jQDateRangeSlider-withRuler-min.js' %}"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/vega@5"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/vega-lite@5.16.3"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>

{% for dashboard, data in dashboards.items %}
  <input type="hidden" id="dashboardEl-{{ dashboard }}" value='{{ data|parse_nones|safe }}'>
{% endfor %}

<script>
let dashboard = `{{ dashboard }}`;
let local = null;
let selectedPredictions = {
  predictions: [],
  sprint: [],
  forecast_map: []
};

function getDashboardEl(dashboard) {
  return document.getElementById(`dashboardEl-${dashboard}`);
}

function dashboardDataGetter(dashboard) {
  const dashboardEl = getDashboardEl(dashboard);
  return JSON.parse(dashboardEl.value);
}

function dashboardQuerySetter(dashboard, updates) {
  const dashboardEl = getDashboardEl(dashboard);
  const dashboardsPrev = dashboardEl.value;
  const updateChartBtn = document.getElementById(`updateChartBtn-${dashboard}`);

  let dashboardData = JSON.parse(dashboardEl.value);

  Object.keys(updates).forEach(key => {
    dashboardData.query[key] = updates[key];
  });

  dashboardEl.value = JSON.stringify(dashboardData);
  dashboardEl.dispatchEvent(new Event('change'));
}

function updateContentState() {
  const dsContent = document.getElementById('dsContent'); 
  if (!menu.classList.contains('retracted')) {
    dsContent.classList.add('expanded');
    dsContent.classList.remove('retracted');
  } else {
    dsContent.classList.add('retracted');
    dsContent.classList.remove('expanded');
  }
}

function changeContent(selectedDashboard) {
  ["predictions", "sprint", "forecast_map"].forEach(dashboard => {
    const contentDiv = document.getElementById(`dsContent-${dashboard}`);
    if (contentDiv) {
      contentDiv.classList.add('hidden');
    }
  });

  const contentDiv = document.getElementById(`dsContent-${selectedDashboard}`);
  if (contentDiv) {
    contentDiv.classList.remove('hidden');
  }
}

async function fetchStartEndWindowDate(dashboard) {
  try {
    const query = dashboardDataGetter(dashboard).query;

    if (
      isValid(query.disease) &&
      isValid(query.time_resolution) &&
      isValid(query.adm_level)
    ) {
      const url = new URL("{% url 'get_predicts_start_end_window_date' %}", window.location.origin);
      url.searchParams.append('dashboard', dashboard);
      url.searchParams.append('disease', query.disease);
      url.searchParams.append('time-resolution', query.time_resolution);
      url.searchParams.append('adm-level', query.adm_level);
      if (query.adm_1) url.searchParams.append('adm-1', query.adm_1);
      if (query.adm_2) url.searchParams.append('adm-2', query.adm_2);

      const response = await fetch(url);
      const result = await response.json();

      return result?.start_window_date && result?.end_window_date
        ? [result.start_window_date, result.end_window_date]
        : [];
    } else {
      return [];
    }
  } catch (error) {
    console.error(error);
    return [];
  }
}

async function getBrowserCity() {
  if (local) {
    return local;
  }

  try {
    const ipApi = await fetch('http://ip-api.com/json');
    const loc = await ipApi.json();

    if (loc.countryCode === 'BR') {
      const uf = loc.region;
      const city = loc.city;

      if (uf && city) {
        const cityInfoResponse = await fetch(`/vis/ibge/city/?name=${encodeURIComponent(city)}&uf=${encodeURIComponent(uf)}`);
        const cityInfo = await cityInfoResponse.json();

        if (cityInfo.geocode) {
          local = cityInfo;
          return cityInfo;
        }
      }
    }
  } catch (error) {
    console.error('Error fetching location:', error);
  }
  return null;
}
</script>


<script>
function isValid(value) {
  return value !== null && value !== undefined;
}

async function fetchData(urlPath, query, required, extraParams = {}) {
  try {
    for (const field of required) {
      if (!isValid(query[field])) {
        throw new Error(`Required query parameter "${field}" is missing or invalid.`);
      }
    }

    const url = new URL(urlPath, window.location.origin);

    const params = {
      disease: "disease",
      time_resolution: "time-resolution",
      adm_level: "adm-level",
      adm_1: "adm-1",
      adm_2: "adm-2",
      adm_3: "adm-3",
      start_window_date: "start-window-date",
      end_window_date: "end-window-date",
      start_date: "start-date",
      end_date: "end-date",
      prediction_ids: "prediction-ids",
    };

    for (const [key, value] of Object.entries(query)) {
      const paramKey = params[key] || key;
      
      if (Array.isArray(value)) {
        value.forEach(item => {
          if (isValid(item)) {
            url.searchParams.append(paramKey, item);
          }
        });
      } else if (isValid(value)) {
        url.searchParams.append(paramKey, value);
      }
    }

    for (const [key, value] of Object.entries(extraParams)) {
      if (isValid(value)) {
        url.searchParams.append(key, value);
      }
    }

    const response = await fetch(url);
    const result = await response.json();

    return result || {};
  } catch (error) {
    console.error(`fetchData (${urlPath}):`, error.message);
    return {};
  }
}

function renderPredictList(data, dashboard) {
  const predictIdsContainer = document.getElementById(`predict-ids-${dashboard}`);
  predictIdsContainer.innerHTML = '';

  if (data.length > 0) {
    const sortedData = data.sort(([idA, scoreA], [idB, scoreB]) => {
      if (scoreA === null && scoreB === null) return 0;
      if (scoreA === null) return 1;
      if (scoreB === null) return -1;
      return scoreA - scoreB;
    });

    const ul = document.createElement('ul');
    ul.classList.add('list-group');

    sortedData.forEach(([predictionId, score]) => {
      const li = document.createElement('li');
      li.classList.add('list-group-item', 'd-flex', 'justify-content-between', 'align-items-center');
      li.id = `${predictionId}`;
      li.innerHTML = `${predictionId} <span class="badge bg-primary">${score !== null ? score : 'N/A'}</span>`;

      if (selectedPredictions[dashboard].includes(predictionId)) {
        li.classList.add('active');
      }

      li.addEventListener('click', function() {
        this.classList.toggle('active');

        if (this.classList.contains('active')) {
          selectedPredictions[dashboard].push(predictionId);
        } else {
          selectedPredictions[dashboard] = selectedPredictions[dashboard].filter(id => id !== predictionId);
        }

        dashboardQuerySetter(dashboard, { "prediction_ids": selectedPredictions[dashboard] });
      });

      ul.appendChild(li);
    });

    predictIdsContainer.appendChild(ul);
  } else {
    predictIdsContainer.innerHTML = '<p>No predictions found</p>';
  }
}

async function fetchPredictList(dashboard) {
  const query = dashboardDataGetter(dashboard).query;
  const requiredFields = [
    'disease',
    'time_resolution',
    'adm_level',
    'start_window_date',
    'end_window_date'
  ];
  const extraParams = {
    dashboard,
    'adm-1': query.adm_1,
    'adm-2': query.adm_2
  };

  const result = await fetchData(
    "{% url 'get_predict_ids' %}",
    query,
    requiredFields,
    extraParams
  );

  renderPredictList(result.predicts, dashboard);
}

async function fetchPredictsChart(dashboard, title, width) {
  const query = dashboardDataGetter(dashboard).query;
  const requiredFields = [
    'disease',
    'adm_level',
    'time_resolution',
    'start_window_date',
    'end_window_date'
  ];
  title = query.adm_1;
  const extraParams = {
    dashboard,
    title,
    width,
    'adm-1': query.adm_1,
    'adm-2': query.adm_2
  };

  const result = await fetchData(
    "{% url 'line_charts_predicts' %}",
    query,
    requiredFields,
    extraParams
  );
  await vegaEmbed(`#chart-container-${dashboard}`, result);
}

async function updateDashboard(dashboard, predictList = false) {
  document.getElementById(`updateChartBtn-${dashboard}`).disabled = true;
  const container = document.getElementById('dsContent');
  const containerWidth = container.getBoundingClientRect().width - 200;

  const title = `${dashboardDataGetter(dashboard).query.adm_1}`;

  if (predictList) {
    await fetchPredictList(dashboard);
  }
  await fetchPredictsChart(dashboard, title, containerWidth);
}

const observer2 = new MutationObserver(function (mutationsList) {
  mutationsList.forEach(function (mutation) {
    if (mutation.attributeName === 'class') {
      updateContentState();
    }
  });
});

async function updateDateWindowRange(dashboard) {
  const [startDate, endDate] = await fetchStartEndWindowDate(dashboard);
  const dateSlider = $(`#windowDatePicker-${dashboard}`)

  try {
    dateSlider.dateRangeSlider("destroy");
  } catch (error) {
    console.log(error);
  }

  dateSlider.dateRangeSlider({
    bounds: {
      min: new Date(startDate),
      max: new Date(endDate)
    },
    defaultValues: {
      min: new Date(startDate),
      max: new Date(endDate)
    },
    range: {
      min: { days: 90 }
    }
  }).bind("valuesChanged", function(e, data) {
    dashboardQuerySetter(
        dashboard,
        {
          "start_window_date": data.values.min.toISOString().slice(0, 10),
          "end_window_date": data.values.max.toISOString().slice(0, 10)
        }
      );
  });
}

</script>


{% include 'vis/dashboard/menu.html' %}
<div id="dsContent" class="container shadow">
{% for name, data in dashboards.items %}
  <div id="dsContent-{{name}}">
    {% if name != "forecast_map" %}
    <div id="chart-container-{{name}}" style="min-height:351px"></div>
    <div id="windowDatePicker-{{name}}" style="margin-bottom:15px"></div>
    <div id="predict-ids-{{name}}"></div>
    {% endif %}
  </div>
{% endfor %}
</div>


<script>
document.addEventListener('DOMContentLoaded', function() {
  getBrowserCity().then(r => {console.log(r)});
  updateContentState();
  changeContent(dashboard);
  observer2.observe(menu, { attributes: true });

  ["predictions", "sprint"].forEach(dashboard => { //, "forecast_map"]
    const dashboardEl = getDashboardEl(dashboard);
    const menuEl = getMenuEl(dashboard);
    const updateChartBtn = document.getElementById(`updateChartBtn-${dashboard}`);
    const data = dashboardDataGetter(dashboard);
    const query = data.query;

    updateChartBtn.disabled = true;

    updateChartBtn.addEventListener('click', () => {
      dashboardQuerySetter(dashboard, menuDataGetter(dashboard).query);
      updateDashboard(dashboard, true);
      updateDateWindowRange(dashboard);
    });

    dashboardQuerySetter(dashboard, menuDataGetter(dashboard).query);
    updateDashboard(dashboard, true);
    updateChartBtn.dispatchEvent(new Event('click'));

    menuEl.addEventListener('change', () => {
      // console.log(menuDataGetter(dashboard).query);
    })

    dashboardEl.addEventListener('change', () => {
      setTimeout(() => {
        updateDashboard(dashboard, false); // TODO: should be true but it also updates the predict list when a list item is selected
      }, 500);
    })

    // if (selectedPredictions[dashboard].length === 0) {
    //   const predictions = [];
    //   document.getElementById(`predict-ids-${dashboard}`).querySelectorAll('li').forEach((li, index) => {
    //     console.log(li);
    //     predictions.push(li.id)
    //   })
    //   console.log(predictions);
    //   dashboardQuerySetter(dashboard, { "prediction_ids": predictions.slice(0, 5) });
    // }
  });
});
</script>

{% endblock %}
