{% extends 'main/base.html' %}
{% load i18n %}
{% load plotly_dash %}
{% load static %}
{% load filters %}

{% block title %}Dashboard{% endblock %}

{% block content %}
<link rel="stylesheet" href="{% static 'css/vis/dashboard/index.css' %}">
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/vega@5"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/vega-lite@5.16.3"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>

{% for dashboard, data in dashboards.items %}
  <input type="hidden" id="dashboardEl-{{ dashboard }}" value='{{ data|parse_nones|safe }}'>
{% endfor %}

<script>
let dashboard = `{{ dashboard }}`;
let local = null;
let selectedPredictions = {
  predictions: [],
  sprint: [],
  forecast_map: []
};

function getDashboardEl(dashboard) {
  return document.getElementById(`dashboardEl-${dashboard}`);
}

function dashboardsQueryGetter(dashboard) {
  const dashboardEl = getDashboardEl(dashboard);
  return JSON.parse(dashboardEl.value);
}

function dashboardsQuerySetter(dashboard, updates) {
  const dashboardEl = getDashboardEl(dashboard);
  const dashboardsPrev = dashboardEl.value;

  let dashboardData = JSON.parse(dashboardEl.value);

  Object.keys(updates).forEach(key => {
    dashboardData.query[key] = updates[key];
  });

  const dashboardsNew = JSON.stringify(dashboardData);

  if (dashboardsPrev !== dashboardsNew) {
    console.log(dashboardsNew);
    dashboardEl.value = dashboardsNew;
    setTimeout(function() {
      dashboardEl.dispatchEvent(new Event('change'));
    }, 300);
  }
}

function updateContentState() {
  const dsContent = document.getElementById('dsContent'); 
  if (!menu.classList.contains('retracted')) {
    dsContent.classList.add('expanded');
    dsContent.classList.remove('retracted');
  } else {
    dsContent.classList.add('retracted');
    dsContent.classList.remove('expanded');
  }
}

function changeContent(selectedDashboard) {
  ["predictions", "sprint", "forecast_map"].forEach(dashboard => {
    const contentDiv = document.getElementById(`dsContent-${dashboard}`);
    if (contentDiv) {
      contentDiv.classList.add('hidden');
    }
  });

  const contentDiv = document.getElementById(`dsContent-${selectedDashboard}`);
  if (contentDiv) {
    contentDiv.classList.remove('hidden');
  }
}

async function fetchStartEndWindowDate(dashboard) {
  try {
    const query = dashboardsQueryGetter(dashboard).query;

    if (
      isValid(query.disease) &&
      isValid(query.time_resolution) &&
      isValid(query.adm_level)
    ) {
      const url = new URL("{% url 'get_predicts_start_end_window_date' %}", window.location.origin);
      url.searchParams.append('dashboard', dashboard);
      url.searchParams.append('disease', query.disease);
      url.searchParams.append('time-resolution', query.time_resolution);
      url.searchParams.append('adm-level', query.adm_level);
      if (query.adm_1) url.searchParams.append('adm-1', query.adm_1);
      if (query.adm_2) url.searchParams.append('adm-2', query.adm_2);

      const response = await fetch(url);
      const result = await response.json();

      return result?.start_window_date && result?.end_window_date
        ? [result.start_window_date, result.end_window_date]
        : [];
    } else {
      return [];
    }
  } catch (error) {
    console.error(error);
    return [];
  }
}

async function getBrowserCity() {
  if (local) {
    return local;
  }

  try {
    const ipApi = await fetch('http://ip-api.com/json');
    const loc = await ipApi.json();

    if (loc.countryCode === 'BR') {
      const uf = loc.region;
      const city = loc.city;

      if (uf && city) {
        const cityInfoResponse = await fetch(`/vis/ibge/city/?name=${encodeURIComponent(city)}&uf=${encodeURIComponent(uf)}`);
        const cityInfo = await cityInfoResponse.json();

        if (cityInfo.geocode) {
          local = cityInfo;
          return cityInfo;
        }
      }
    }
    console.log(local);
  } catch (error) {
    console.error('Error fetching location:', error);
  }
  return null;
}
</script>


{% include 'vis/dashboard/menu.html' %}
<div id="dsContent" class="container shadow">
{% for name, data in dashboards.items %}
  <div id="dsContent-{{name}}">
    {% if name != "forecast_map" %}
    <div id="chart-container-{{name}}"></div>
    <div id="predict-ids-{{name}}"></div>
    {% endif %}
  </div>
{% endfor %}

</div>

<script>
function isValid(value) {
  return value !== null && value !== undefined;
}

async function fetchData(urlPath, query, required, extraParams = {}) {
  try {
    for (const field of required) {
      if (!isValid(query[field])) {
        throw new Error(`Required query parameter "${field}" is missing or invalid.`);
      }
    }

    const url = new URL(urlPath, window.location.origin);

    const params = {
      disease: "disease",
      time_resolution: "time-resolution",
      adm_level: "adm-level",
      adm_1: "adm-1",
      adm_2: "adm-2",
      adm_3: "adm-3",
      start_window_date: "start-window-date",
      end_window_date: "end-window-date",
      start_date: "start-date",
      end_date: "end-date",
      prediction_ids: "prediction-ids",
    };

    for (const [key, value] of Object.entries(query)) {
      const paramKey = params[key] || key;
      
      if (Array.isArray(value)) {
        value.forEach(item => {
          if (isValid(item)) {
            url.searchParams.append(paramKey, item);
          }
        });
      } else if (isValid(value)) {
        url.searchParams.append(paramKey, value);
      }
    }

    for (const [key, value] of Object.entries(extraParams)) {
      if (isValid(value)) {
        url.searchParams.append(key, value);
      }
    }

    const response = await fetch(url);
    const result = await response.json();

    return result || {};
  } catch (error) {
    console.error(`fetchData (${urlPath}):`, error.message);
    return {};
  }
}

function renderPredictList(data, dashboard) {
  const predictIdsContainer = document.getElementById(`predict-ids-${dashboard}`);
  predictIdsContainer.innerHTML = '';

  if (data.length > 0) {
    const sortedData = data.sort(([idA, scoreA], [idB, scoreB]) => {
      if (scoreA === null && scoreB === null) return 0;
      if (scoreA === null) return 1;
      if (scoreB === null) return -1;
      return scoreA - scoreB;
    });

    const ul = document.createElement('ul');
    ul.classList.add('list-group');

    let selectionTimeout;

    sortedData.forEach(([predictionId, score]) => {
      const li = document.createElement('li');
      li.classList.add('list-group-item', 'd-flex', 'justify-content-between', 'align-items-center');
      li.id = `prediction-${predictionId}`;
      li.innerHTML = `${predictionId} <span class="badge bg-primary">${score !== null ? score : 'N/A'}</span>`;

      if (selectedPredictions[dashboard].includes(predictionId)) {
        li.classList.add('active');
      }

      li.addEventListener('click', function() {
        this.classList.toggle('active');

        if (this.classList.contains('active')) {
          selectedPredictions[dashboard].push(predictionId);
        } else {
          selectedPredictions[dashboard] = selectedPredictions[dashboard].filter(id => id !== predictionId);
        }

        clearTimeout(selectionTimeout);

        selectionTimeout = setTimeout(function() {
          predictionItemOnChange(dashboard, selectedPredictions[dashboard]);
        }, 500);
      });

      ul.appendChild(li);
    });

    predictIdsContainer.appendChild(ul);
  } else {
    predictIdsContainer.innerHTML = '<p>No predictions found</p>';
  }
}

function predictionItemOnChange(dashboard, selectedIds) {
  dashboardsQuerySetter(dashboard, { "prediction_ids": Array.from(selectedIds) });
}

async function fetchPredictList(dashboard) {
  const query = dashboardsQueryGetter(dashboard).query;
  const requiredFields = [
    'disease',
    'time_resolution',
    'adm_level',
    'start_window_date',
    'end_window_date'
  ];
  const extraParams = {
    dashboard,
    'adm-1': query.adm_1,
    'adm-2': query.adm_2
  };

  const result = await fetchData(
    "{% url 'get_predict_ids' %}",
    query,
    requiredFields,
    extraParams
  );

  renderPredictList(result.predicts, dashboard);
}

async function fetchBaseLineChart(dashboard, title, width) {
  const query = dashboardsQueryGetter(dashboard).query;
  const requiredFields = ['start_window_date', 'end_window_date'];
  const extraParams = { title, width };

  const result = await fetchData(
    "{% url 'line_charts_base' %}",
    query,
    requiredFields,
    extraParams
  );
  await vegaEmbed(`#chart-container-${dashboard}`, result);
}

async function fetchDataChart(dashboard, width) {
  const query = dashboardsQueryGetter(dashboard).query;
  const requiredFields = [
    'disease',
    'adm_level',
    'start_window_date',
    'end_window_date'
  ];
  const extraParams = {
    dashboard,
    width,
    'adm-1': query.adm_1,
    'adm-2': query.adm_2
  };

  const result = await fetchData(
    "{% url 'line_charts_data' %}",
    query,
    requiredFields,
    extraParams
  );
  await vegaEmbed(`#chart-container-${dashboard}`, result);
}

async function fetchPredictsChart(dashboard, title, width) {
  const query = dashboardsQueryGetter(dashboard).query;
  const requiredFields = [
    'disease',
    'adm_level',
    'time_resolution',
    'start_window_date',
    'end_window_date'
  ];
  const extraParams = {
    dashboard,
    title,
    width,
    'adm-1': query.adm_1,
    'adm-2': query.adm_2
  };

  const result = await fetchData(
    "{% url 'line_charts_predicts' %}",
    query,
    requiredFields,
    extraParams
  );
  await vegaEmbed(`#chart-container-${dashboard}`, result);
}


async function updateDashboard(dashboard) {
  await getBrowserCity();
  console.log(local);
  const container = document.getElementById('dsContent');
  const containerWidth = container.getBoundingClientRect().width - 200;

  const title = 'New cases';

  await fetchPredictList(dashboard);
  await fetchBaseLineChart(dashboard, title, containerWidth);
  await fetchDataChart(dashboard, containerWidth);
  await fetchPredictsChart(dashboard, title, containerWidth);
}

const observer2 = new MutationObserver(function (mutationsList) {
  mutationsList.forEach(function (mutation) {
    if (mutation.attributeName === 'class') {
      updateContentState();
    }
  });
});

document.addEventListener('DOMContentLoaded', function() {
  updateContentState();
  changeContent(dashboard);
  updateDashboard(dashboard);
  observer2.observe(menu, { attributes: true });
});

["predictions", "sprint", "forecast_map"].forEach(dashboard => {
  const dashboardEl = getDashboardEl(dashboard);
  const data = dashboardsQueryGetter(dashboard);
  const query = data.query;

  dashboardEl.addEventListener('change', () => {
    updateAdmMenu(dashboard);
  });
});
</script>

{% endblock %}
