# Generated by Django 4.2.23 on 2026-01-02 00:42

from django.db import migrations
from django.db.models import Q


def migrate_legacy_models(apps, schema_editor):
    # Load Models
    OldModel = apps.get_model("vis", "Model")
    RepositoryModel = apps.get_model("vis", "RepositoryModel")
    Repository = apps.get_model("vis", "Repository")
    Disease = apps.get_model("vis", "Disease")
    Sprint = apps.get_model("vis", "Sprint")
    User = apps.get_model(
        "users", "CustomUser"
    )  # Adjust 'users' if your app label differs

    # 1. Pre-fetch or Create Diseases
    # Maps legacy choice keys (chikungunya, dengue, zika) to DB Objects
    disease_map = {}
    for alias, name in [
        ("dengue", "Dengue"),
        ("zika", "Zika"),
        ("chikungunya", "Chikungunya"),
    ]:
        obj, _ = Disease.objects.get_or_create(
            alias=alias, defaults={"name": name}
        )
        disease_map[alias] = obj

    # 2. Pre-fetch Sprints
    sprint_2024 = Sprint.objects.filter(year=2024).first()
    sprint_2025 = Sprint.objects.filter(year=2025).first()

    for old in OldModel.objects.all():
        # --- A. Create/Get Repository ---
        # Format is typically "Owner/RepoName"
        repo_string = old.repository.strip()

        owner_username = "unknown"
        repo_name = repo_string

        if "/" in repo_string:
            parts = repo_string.split("/", 1)
            owner_username = parts[0]
            repo_name = parts[1]

        # Try to find the local user that matches the repo owner string
        # If not found, we leave owner=None as per your nullable field definition
        owner_user = User.objects.filter(
            username__iexact=owner_username
        ).first()

        repository, _ = Repository.objects.get_or_create(
            repo_id=repo_string,  # Assuming the full string is the unique ID
            defaults={
                "name": repo_name,
                "provider": "github",  # Defaulting to GitHub
                "owner": owner_user,
                "organization": None,  # Explicitly None as requested
                "active": True,
            },
        )

        # --- B. Determine Category ---
        # Logic: Combine the 3 booleans into the single Choice Field
        is_spatial = old.spatial or False
        is_temporal = old.temporal or False
        is_categorical = old.categorical or False

        new_category = "quantitative"  # Default fallback

        if is_spatial and is_temporal:
            new_category = (
                "spatio_temporal_categorical"
                if is_categorical
                else "spatio_temporal_quantitative"
            )
        elif is_spatial:
            new_category = (
                "spatial_categorical"
                if is_categorical
                else "spatial_quantitative"
            )
        elif is_categorical:
            new_category = "categorical"
        elif is_temporal:
            new_category = "quantitative"

        # --- C. Determine Sprint ---
        # If old.sprint is True, we try to match the creation year
        sprint_obj = None
        if old.sprint:
            year = old.created.year
            if year == 2024:
                sprint_obj = sprint_2024
            elif year >= 2025:
                sprint_obj = sprint_2025
            else:
                # Fallback for older data marked as sprint
                sprint_obj = sprint_2024

        # --- D. Create New RepositoryModel ---
        RepositoryModel.objects.create(
            repository=repository,
            disease=disease_map.get(old.disease, None),
            description=old.description,
            category=new_category,
            adm_level=old.adm_level or 0,  # Default to National if null
            time_resolution=old.time_resolution or "week",
            sprint=sprint_obj,
            # Note: 'created' and 'updated' are auto_now, so they will be set to NOW()
            # If you need to preserve history, you must temporarily disable auto_now
            # or update directly via SQL, but for most migrations this is acceptable.
        )


class Migration(migrations.Migration):
    dependencies = [
        ("registry", "0069_create_former_sprints"),
    ]

    operations = []
